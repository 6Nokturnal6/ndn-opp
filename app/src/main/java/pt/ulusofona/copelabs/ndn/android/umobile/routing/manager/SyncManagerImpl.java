package pt.ulusofona.copelabs.ndn.android.umobile.routing.manager;

import android.content.Context;
import android.os.Handler;
import android.util.Log;

import net.named_data.jndn.Data;
import net.named_data.jndn.Face;
import net.named_data.jndn.Interest;
import net.named_data.jndn.InterestFilter;
import net.named_data.jndn.Name;
import net.named_data.jndn.OnData;
import net.named_data.jndn.OnInterestCallback;
import net.named_data.jndn.OnRegisterFailed;
import net.named_data.jndn.OnRegisterSuccess;
import net.named_data.jndn.OnTimeout;
import net.named_data.jndn.sync.ChronoSync2013;


import org.apache.commons.lang3.SerializationUtils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import pt.ulusofona.copelabs.ndn.android.umobile.routing.models.Plsa;
import pt.ulusofona.copelabs.ndn.android.umobile.routing.tasks.ExpressInterestTask;
import pt.ulusofona.copelabs.ndn.android.umobile.routing.tasks.JndnProcessEventTask;
import pt.ulusofona.copelabs.ndn.android.umobile.routing.tasks.RegisterChronoSyncTask;
import pt.ulusofona.copelabs.ndn.android.umobile.routing.tasks.RegisterPrefixTask;
import pt.ulusofona.copelabs.ndn.android.umobile.routing.tasks.RibUpdater;
import pt.ulusofona.copelabs.ndn.android.umobile.routing.tasks.SendDataTask;

/**
 * @version 1.0
 * COPYRIGHTS COPELABS/ULHT, LGPLv3.0, 2018-03-07
 * This class implements the methods needed to use ChronoSync2013.
 *
 * @author Omar Aponte (COPELABS/ULHT)
 */

public class SyncManagerImpl implements ChronoSync2013.OnInitialized,
        ChronoSync2013.OnReceivedSyncState,
        OnRegisterFailed,
        OnRegisterSuccess,
        RegisterChronoSyncTask.ChronoInterface,
        OnInterestCallback,
        OnData,
        OnTimeout,
        SyncManager{

    @Override
    public void start() {
        registerChronoSync();
    }

    @Override
    public void stop() {
        mChronoSync.shutdown();
    }

    /** This interface is used to notify when a new PLSA arrives to the devices. */
    public interface SyncManagerInterface{
        void OnNewPlsa(Plsa plsa);
    }

    private static final String TAG = SyncManagerImpl.class.getSimpleName();

    /** Integer used to define the time to check events in the face. */
    private static int PROCESS_INTERVAL = 1000;

    /** Face use to communicate with NFD. */
    private Face mFace = new Face ("127.0.0.1");

    /** ChronoSync used to sinchronize data. */
    private ChronoSync2013 mChronoSync;

    /** Prefix requested by ChronoSync. And it is used to notify when new data was created by
     * others users. */
    private String mApplicationDataPrefix = "/ndn/broadcast/dabber/";

    /** Prefix requested by ChronoSync. Used for internal process. */
    private String mApplicationBroadcastPrefix= "/ndn/broadcast/ndnopp/dabber";

    /** Context of the application. */
    private Context mContext;

    /** Handler used to keep tracking of events in the Face. */
    private Handler mHandler = new Handler();

    /** Runnable used to start the JndnProcessEventTask. */
    private Runnable mJndnProcessor;

    /** This masp is used to save the data generated by the user. */
    private HashMap<String, Data> mDataGeneratedMap = new HashMap<>();

    /** This array is used to save the interests expressed by the chronosync. */
    private ArrayList<String> mInterestExpresed = new ArrayList<>();

    /** This variable is used to save the status on or off of ChronoSync */
    private boolean ChronoSyncOn = false;

    /**
     * Constructor of the SyncManagerImpl
     * @param context
     */
    public SyncManagerImpl(String uuid, Context context) {
        mApplicationDataPrefix = mApplicationDataPrefix+uuid;
        mContext = context;
        startProcessEventTask();
        mHandler.postDelayed(mJndnProcessor, PROCESS_INTERVAL);
        new RegisterPrefixTask(mFace, mApplicationDataPrefix, this, this, mContext).execute();

    }

    /** This method starts the task to check if there is a new change in the face */
    private void startProcessEventTask() {
        mJndnProcessor = new Runnable() {
            @Override
            public void run() {
                new JndnProcessEventTask(mFace).execute();
                mHandler.postDelayed(mJndnProcessor, PROCESS_INTERVAL);
            }
        };
    }

    /**
     * Registers the ChronoSync.
     */
    public void registerChronoSync() {
        new RegisterChronoSyncTask(mFace,
                mApplicationDataPrefix,
                mApplicationBroadcastPrefix,
                this,
                this,
                this,
                this,
                mContext).execute();
    }

    public String getmApplicationDataPrefix(){
        return mApplicationDataPrefix;
    }

    @Override
    public void onInitialized() {
        Log.d(TAG, "OnInitialized");
    }

    /**
     * This method is used to Know when a new data is createed by other user.
     * @param list List with the state of the others users.
     * @param b
     */
    @Override
    public void onReceivedSyncState(List list, boolean b) {
        Log.d(TAG, "OnReceivedSyncState");
        for (Object syncStateOb : list) {

            ChronoSync2013.SyncState syncState = (ChronoSync2013.SyncState) syncStateOb;

            String syncPrefix = syncState.getDataPrefix();

            long syncSeq = syncState.getSequenceNo();

            if (syncSeq > 0) {
                Log.d(TAG, syncPrefix);
                Log.d(TAG, syncSeq + "");
                if (!mInterestExpresed.contains(syncPrefix + "/" + syncSeq)) {
                    new ExpressInterestTask(mFace, new Interest(new Name(syncPrefix + "/" + syncSeq), 43200000), this, this).execute();
                    mInterestExpresed.add(syncPrefix + "/" + syncSeq);
                }
            }

        }

    }

    /**
     * This method is called when the registration of a prefix fails.
     */
    @Override
    public void onRegisterFailed(Name name) {
        Log.d(TAG, "OnRegisterFailed");
    }

    /**
     * This method is called when the registration of a prefix is succeed.
     * @param prefix
     * @param registeredPrefixId
     */
    @Override
    public void onRegisterSuccess(Name prefix, long registeredPrefixId) {
        Log.d(TAG, "Register ok");
        registerChronoSync();

    }

    /** This method is called when ChronoSync is successfully registered. */
    @Override
    public void onChronoSyncRegistered(ChronoSync2013 chronoSync2013) {
        mChronoSync = chronoSync2013;
        ChronoSyncOn=true;
    }

    @Override
    public void onInterest(Name prefix, Interest interest, Face face, long interestFilterId, InterestFilter filter) {
        Log.d(TAG, "onInterest: " + interest.getName());
        if (mDataGeneratedMap.containsKey(interest.getName().toString()))
            new SendDataTask(mFace, mDataGeneratedMap.get(interest.getName().toString())).execute();

    }

    /**
     * This method contains a thread that keep in track the number of the sequence of ChronoSync
     */
    public void increaseSequenceNos() {

        // Create a new thread to publish new sequence numbers
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    if (mChronoSync != null) {
                        try {
                            Thread.sleep(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        mChronoSync.publishNextSequenceNo();

                        Log.d(TAG, "Published next seq number. Seq is now: " + mChronoSync.getSequenceNo());
                    }
                } catch (IOException | net.named_data.jndn.security.SecurityException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    /**
     * This function is used to send data packets. Every time that a new data is sent
     * is called the method increaseSequenceNos.
     * @param data data packet.
     */
    public void senData(Data data) {
        Log.d(TAG, "Putting data on hashmap: " + data.getName().toString());
        mDataGeneratedMap.put(data.getName().toString(), data);
        try {
            increaseSequenceNos();
        }catch (Exception e){
            Log.d(TAG, "Error generating next sequence");
        }
    }

    /**
     * This method is called when a new data packet arrives to the device
     * @param interest Interest of the data.
     * @param data Data packet.
     */
    @Override
    public void onData(Interest interest, Data data) {
        Log.d(TAG, "onData: " + interest.getName());
        Plsa plsa = SerializationUtils.deserialize(data.getContent().getImmutableArray());
        SyncManagerListeners.notifyListeners(plsa);
        Log.d(TAG, "name " + plsa.getName() + " cost: " + plsa.getCost() + " neighbor: " + plsa.getNeighbor());
       // mInterface.OnNewPlsa(plsa);

    }

    @Override
    public void onTimeout(Interest interest) {
        Log.d(TAG, "onTimeOut interest: " + interest.getName().toString());

    }

    /**
     * Get the number on the sequence of the chronosync.
     * @return Number of the sequence.
     */
    public long getSequence() {
        return mChronoSync.getSequenceNo() + 1;
    }

    public boolean isChronoSyncOn(){
        return ChronoSyncOn;
    }

}

